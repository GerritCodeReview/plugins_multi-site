{
  "comments": [
    {
      "key": {
        "uuid": "69cf05b1_0d54af23",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 118,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-02-28T13:07:48Z",
      "side": 1,
      "message": "This is a very good suggestion, reminds me Spokes the solution implemented at GitHub (see https://githubengineering.com/building-resilience-in-spokes/)\n\nI really like the idea, shall we tackle this at the next Hackathon in Munich?",
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "7e5ebf9e_f2c15217",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 118,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-02-28T14:10:13Z",
      "side": 1,
      "message": "\u003e I really like the idea, shall we tackle this at the next Hackathon in Munich?\n\nYes, this is one of the ideas I have for the Hackathon in Munich. If you are interested\nthen even better :-)",
      "parentUuid": "69cf05b1_0d54af23",
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "af6f3de4_f5c6c186",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 119,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-02-28T13:07:48Z",
      "side": 1,
      "message": "Acknowledged to the client",
      "range": {
        "startLine": 119,
        "startChar": 31,
        "endLine": 119,
        "endChar": 39
      },
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "e19641c0_4d5023e2",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 119,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-03-07T13:09:26Z",
      "side": 1,
      "message": "IMO, it is not only about acknowledging to the client.\nIf a write operation couldn\u0027t be replicated then IMO it is important to also reject (or rollback) it in the instance processing the client request. If we:\n(a) fail to replicate\n(b) accept the push in the instance processing the request\n(c) send an error to the client\n\nthen the client would intuitively expect that the operation succeeds if he (re)tries later.\nHowever, due to (b), a retried push may fail (\"no new changes\") because the pushed commit is\nalready known.",
      "parentUuid": "af6f3de4_f5c6c186",
      "range": {
        "startLine": 119,
        "startChar": 31,
        "endLine": 119,
        "endChar": 39
      },
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "eb3ca4ff_02a9583a",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-02-28T13:07:48Z",
      "side": 1,
      "message": "100% loss-less",
      "range": {
        "startLine": 120,
        "startChar": 35,
        "endLine": 120,
        "endChar": 39
      },
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b2d559ff_db9b2485",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 1059414
      },
      "writtenOn": "2019-02-28T15:47:47Z",
      "side": 1,
      "message": "This is a very good point but I think that discriminating between Sync/Async is not the right view. \n\nI think we should rather talk about the durability of the replication information and the failure of write operation if the publication of the replication info fails.\n\nIn this case we could have eventual consistency and no data loss in Async mode.",
      "parentUuid": "eb3ca4ff_02a9583a",
      "range": {
        "startLine": 120,
        "startChar": 35,
        "endLine": 120,
        "endChar": 39
      },
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "06a54636_03f41607",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-02-28T16:09:05Z",
      "side": 1,
      "message": "\u003e This is a very good point but I think that discriminating between Sync/Async is not the right view. \n\nThe point that Sa≈°a is making is that *IF* you tell the client that a \"git push went through\" you are assuming that the replication will always go well. It is not actually always the case, because if the server-1 blows up (all destroyed, including data) before the data gets replicated to server-2, the push data has gone.\n\n\u003e I think we should rather talk about the durability of the replication information and the failure of write operation if the publication of the replication info fails.\n\nReplication is already durable: it will eventually be replicated assuming that server-1 did not blow up (my example above).\n\n\u003e In this case we could have eventual consistency and no data loss in Async mode.\n\nNot always, that\u0027s why \"sync replication\" is the 100% loss-less, otherwise you have a probability of inconsistency (let\u0027s say 99.999% loss-less but not 100%).\n\nThe CAP theorem is telling us that you can\u0027t have C(onsistency) + A(vailability) + P(erformance) at the same time.\n\nI believe that letting the user chose which one to give priority to is the right way, including \"sync replication\" when needed.",
      "parentUuid": "b2d559ff_db9b2485",
      "range": {
        "startLine": 120,
        "startChar": 35,
        "endLine": 120,
        "endChar": 39
      },
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "136bf7b4_a0861ea8",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-02-28T16:15:27Z",
      "side": 1,
      "message": "\u003e I think we should rather talk about the durability of the replication information and the failure of write operation if the publication of the replication info fails.\n\u003e \n\u003e In this case we could have eventual consistency and no data loss in Async mode.\n\nI am not sure. We had a real disaster case where an admin by mistake deleted all *.pack\nfiles instead of deleting *.keep files in one repository in Gerrit. In this case even\nif the replication info was published, there was no way to recover some commits without\nhaving to ask developers to search for these commits in their local repositories.\n\nAnother interesting learning from that incident was that Gerrit didn\u0027t start to fail\nup until 1 hour after the *.pack files were deleted. This is because most of the pack\nfile content was cached in memory and Gerrit didn\u0027t realize that the *.pack files were\nmissing. So we had (thin) pack files, uploaded from pushing new changes, which were\nreferencing objects which were supposed to be in other packs, but they actually were not there.\n\nYet another interesting point was that the replication was about 1 hour behind the\nmaster because of a performance issue which was ongoing at the same time. This amplified\nthe effect(s) of the incident.\n\nThese are the reasons I started to think about synchronous replication as a mean to\nguarantee disaster recovery.",
      "parentUuid": "b2d559ff_db9b2485",
      "range": {
        "startLine": 120,
        "startChar": 35,
        "endLine": 120,
        "endChar": 39
      },
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "b4e39629_78b00e03",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 120,
      "author": {
        "id": 1059414
      },
      "writtenOn": "2019-02-28T16:26:58Z",
      "side": 1,
      "message": "Understood and, as you say correctly, there will be a tradeoff in Availability.\n\nIf you want ALL replicas to acknowledge the replication speed and availability will be difficult to guarantee with the growth of the cluster.",
      "parentUuid": "136bf7b4_a0861ea8",
      "range": {
        "startLine": 120,
        "startChar": 35,
        "endLine": 120,
        "endChar": 39
      },
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "80c1ff22_04eaf783",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-02-28T13:07:48Z",
      "side": 1,
      "message": "Actually there is, but only from the clients that pushed the commit in the first place.\nGit is a distributed version control system after all.",
      "range": {
        "startLine": 122,
        "startChar": 3,
        "endLine": 122,
        "endChar": 40
      },
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "ccfe4a9a_d6bbb336",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1003873
      },
      "writtenOn": "2019-02-28T14:10:13Z",
      "side": 1,
      "message": "Technically correct but such an action would be really impractical. Imagine writing\nan email to 100s of developers with a list of (missing) commit SHA1s in the email and asking\nwho can push them again. This is not how you want to deal with your customers ;-)",
      "parentUuid": "80c1ff22_04eaf783",
      "range": {
        "startLine": 122,
        "startChar": 3,
        "endLine": 122,
        "endChar": 40
      },
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    },
    {
      "key": {
        "uuid": "939a491d_cbdba9e5",
        "filename": "DESIGN.md",
        "patchSetId": 2
      },
      "lineNbr": 122,
      "author": {
        "id": 1006192
      },
      "writtenOn": "2019-02-28T16:09:05Z",
      "side": 1,
      "message": "\u003e Technically correct but such an action would be really impractical. Imagine writing\n\u003e an email to 100s of developers with a list of (missing) commit SHA1s in the email and asking\n\u003e who can push them again. This is not how you want to deal with your customers ;-)\n\nActually, with the JGit packlist caching issue we have at the moment in v2.16, that is the case already now and happened in real life in production, even without multi-site :-(",
      "parentUuid": "ccfe4a9a_d6bbb336",
      "range": {
        "startLine": 122,
        "startChar": 3,
        "endLine": 122,
        "endChar": 40
      },
      "revId": "27938b38b58b7dbabaa2cccbde6896a1979045a3",
      "serverId": "173816e5-2b9a-37c3-8a2e-48639d4f1153",
      "unresolved": true
    }
  ]
}