// Copyright (C) 2020 The Android Open Source Project
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package com.googlesource.gerrit.plugins.multisite.forwarder.broker;

import com.gerritforge.gerrit.eventbroker.EventsBrokerApiWrapper;
import com.google.common.base.Strings;
import com.google.gerrit.server.config.GerritInstanceId;
import com.googlesource.gerrit.plugins.multisite.Configuration;
import com.googlesource.gerrit.plugins.multisite.broker.BrokerMetrics;
import com.googlesource.gerrit.plugins.multisite.forwarder.ForwarderTask;
import com.googlesource.gerrit.plugins.multisite.forwarder.events.EventTopic;
import com.googlesource.gerrit.plugins.multisite.forwarder.events.MultiSiteEvent;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

public abstract class BrokerForwarder {
  private static final Logger log = LoggerFactory.getLogger(BrokerForwarder.class);
  private static final CharSequence HIGH_AVAILABILITY_PLUGIN = "/plugins/high-availability/";
  private static final CharSequence HIGH_AVAILABILITY_FORWARDER = "Forwarded-Index-Event";
  private static final CharSequence HIGH_AVAILABILITY_BATCH_FORWARDER =
      "Forwarded-BatchIndex-Event";

  private final EventsBrokerApiWrapper broker;
  private final Configuration cfg;
  private final BrokerMetrics metrics;
  private final String nodeInstanceId;

  protected BrokerForwarder(
      EventsBrokerApiWrapper broker,
      Configuration cfg,
      BrokerMetrics metrics,
      @GerritInstanceId String instanceId) {
    this.broker = broker;
    this.cfg = cfg;
    this.metrics = metrics;
    this.nodeInstanceId = instanceId;
  }

  protected boolean currentThreadBelongsToHighAvailabilityPlugin(ForwarderTask task) {
    String currentThreadName = task.getCallerThreadName();

    return currentThreadName.contains(HIGH_AVAILABILITY_PLUGIN)
        || currentThreadName.contains(HIGH_AVAILABILITY_FORWARDER)
        || currentThreadName.contains(HIGH_AVAILABILITY_BATCH_FORWARDER);
  }

  protected boolean send(ForwarderTask task, EventTopic eventTopic, MultiSiteEvent event) {
    // Events generated by the high-availability plugin should be
    // discarded. Sending them around would cause infinite loops.
    if (currentThreadBelongsToHighAvailabilityPlugin(task)) {
      return true;
    }

    if (!nodeInstanceId.equals(event.instanceId)) {
      return true;
    }

    if (Strings.isNullOrEmpty(event.instanceId)) {
      log.warn("Dropping event '{}' because event instance id cannot be null or empty", event);
      return true;
    }

    boolean resultSuccessful = broker.sendSync(eventTopic.topic(cfg), event);
    if (resultSuccessful) {
      metrics.incrementBrokerPublishedMessage();
    } else {
      metrics.incrementBrokerFailedToPublishMessage();
    }

    return resultSuccessful;
  }
}
